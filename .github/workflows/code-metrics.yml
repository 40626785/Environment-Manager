name: Code Quality Metrics

on:
  push:
    branches: [ feature/code-metrics, main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:  # Allow manual triggering

jobs:
  analyze:
    name: Analyze Code Metrics
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for proper analysis
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'
            
    - name: Setup directories
      run: |
        mkdir -p metrics/reports
        
    - name: Install required tools
      run: |
        dotnet tool install --global dotnet-reportgenerator-globaltool
        dotnet tool install --global dotnet-coverage
    
    # Try to build, but continue on error    
    - name: Try to build solution
      id: build_step
      continue-on-error: true
      run: |
        dotnet build EnvironmentManager.sln --configuration Release
        echo "build_succeeded=true" >> $GITHUB_OUTPUT
        
    # Only attempt to run tests if build succeeded
    - name: Run tests with coverage
      id: coverage_step
      if: steps.build_step.outputs.build_succeeded == 'true'
      continue-on-error: true
      run: |
        dotnet-coverage collect -f xml -o metrics/reports/coverage.xml \
          "dotnet test EnvironmentManager.Test/EnvironmentManager.Test.csproj --no-build --configuration Release"
        echo "coverage_generated=true" >> $GITHUB_OUTPUT
          
    # Only generate coverage report if tests ran successfully
    - name: Generate code coverage report
      if: steps.coverage_step.outputs.coverage_generated == 'true'
      continue-on-error: true
      run: |
        reportgenerator \
          -reports:metrics/reports/coverage.xml \
          -targetdir:metrics/reports/coverage \
          -reporttypes:Html;MarkdownSummary
          
    # Extract coverage percentage if report was generated
    - name: Extract coverage percentage
      id: coverage
      if: steps.coverage_step.outputs.coverage_generated == 'true'
      continue-on-error: true
      run: |
        if [ -f "metrics/reports/coverage/Summary.md" ]; then
          LINE_COVERAGE=$(grep -oP 'Line coverage: \K[0-9.]+' metrics/reports/coverage/Summary.md || echo "0.0")
          echo "line_coverage=${LINE_COVERAGE}" >> $GITHUB_OUTPUT
          BRANCH_COVERAGE=$(grep -oP 'Branch coverage: \K[0-9.]+' metrics/reports/coverage/Summary.md || echo "0.0")
          echo "branch_coverage=${BRANCH_COVERAGE}" >> $GITHUB_OUTPUT
        else
          echo "line_coverage=0.0" >> $GITHUB_OUTPUT
          echo "branch_coverage=0.0" >> $GITHUB_OUTPUT
        fi
        
    # Skip build and test steps if they're failing
    # We can still analyze metrics without building
    
    - name: Generate code metrics (without build dependency)
      shell: pwsh
      run: |
        # Create directory for metrics
        New-Item -Path "metrics/reports" -ItemType Directory -Force | Out-Null
        
        # Debug info
        Write-Host "Working directory: $(Get-Location)"
        Write-Host "Directory structure:"
        Get-ChildItem -Path . -Directory | ForEach-Object { Write-Host "  $($_.Name)" }
        
        # Check if EnvironmentManager directory exists
        if (!(Test-Path -Path "EnvironmentManager")) {
            Write-Host "WARNING: EnvironmentManager directory not found. Listing available directories:"
            Get-ChildItem -Path . -Directory | ForEach-Object { Write-Host "  $($_.Name)" }
        }
        
        # Analyze codebase using PowerShell
        $csFiles = Get-ChildItem -Path . -Filter "*.cs" -Recurse -ErrorAction Continue | 
                    Where-Object { $_.FullName -notmatch "(/|\\)obj(/|\\)" -and 
                                  $_.FullName -notmatch "(/|\\)bin(/|\\)" }
        
        $codeFiles = $csFiles.Count
        Write-Host "Found $codeFiles C# files"
        
        # Print first 10 files for debugging
        Write-Host "First 10 C# files:"
        $csFiles | Select-Object -First 10 | ForEach-Object { Write-Host "  $($_.FullName)" }
        
        # Calculate documentation coverage
        $totalPublicMembers = 0
        $documentedMembers = 0
        $fileDetails = @()
            
        foreach ($file in $csFiles) {
            try {
                $content = Get-Content -Path $file.FullName -Raw -ErrorAction Continue
                if ($content) {
                    # Count public members
                    $memberMatches = [regex]::Matches($content, "public\s+(static\s+)?(virtual\s+)?(override\s+)?(\w+)(\s+\w+)?\s+(\w+)")
                    $memberCount = $memberMatches.Count
                    
                    # Count documented members
                    $docMatches = [regex]::Matches($content, "///\s*<summary>")
                    $docCount = $docMatches.Count
                    
                    $totalPublicMembers += $memberCount
                    $documentedMembers += $docCount
                    
                    $fileDetails += [PSCustomObject]@{
                        File = $file.Name
                        PublicMembers = $memberCount
                        DocumentedMembers = $docCount
                        DocPercentage = if ($memberCount -gt 0) { [math]::Round(($docCount / $memberCount) * 100, 1) } else { 0 }
                    }
                }
            }
            catch {
                Write-Host "Error processing file $($file.FullName): $_"
            }
        }
        
        # Show details for the top 10 files with most public members
        Write-Host "`nTop 10 files by public member count:"
        $fileDetails | Sort-Object -Property PublicMembers -Descending | Select-Object -First 10 | 
            Format-Table -Property File, PublicMembers, DocumentedMembers, DocPercentage
        
        if ($totalPublicMembers -gt 0) {
            $docCoverage = [math]::Round(($documentedMembers / $totalPublicMembers) * 100, 1)
        }
        else {
            $docCoverage = 0
            Write-Host "WARNING: No public members found for documentation analysis"
        }
        
        # Calculate cyclomatic complexity
        $totalComplexity = 0
        $methodCount = 0
        $complexityByFile = @()
        
        foreach ($file in $csFiles) {
            try {
                $content = Get-Content -Path $file.FullName -Raw -ErrorAction Continue
                if ($content) {
                    # Count methods more accurately with better regex
                    $methodMatches = [regex]::Matches($content, "(public|private|protected|internal)\s+(static\s+)?(virtual\s+)?(override\s+)?(\w+)(\s+\w+)?\s+(\w+)\s*\(")
                    $fileMethodCount = $methodMatches.Count
                    
                    # Calculate complexity based on conditional statements
                    $ifCount = [regex]::Matches($content, "(\s|^)if\s*\(").Count
                    $elseIfCount = [regex]::Matches($content, "(\s|^)else\s+if\s*\(").Count
                    $elseCount = [regex]::Matches($content, "(\s|^)else(\s|{)").Count
                    $forCount = [regex]::Matches($content, "(\s|^)for\s*\(").Count
                    $foreachCount = [regex]::Matches($content, "(\s|^)foreach\s*\(").Count
                    $whileCount = [regex]::Matches($content, "(\s|^)while\s*\(").Count
                    $doWhileCount = [regex]::Matches($content, "(\s|^)do\s*{").Count
                    $switchCount = [regex]::Matches($content, "(\s|^)switch\s*\(").Count
                    $caseCount = [regex]::Matches($content, "(\s|^)case\s+").Count
                    $catchCount = [regex]::Matches($content, "(\s|^)catch\s*[({]").Count
                    $conditionalOpCount = [regex]::Matches($content, "\?\s*[^;]+\s*:\s*[^;]+").Count
                    
                    $fileBranchCount = $ifCount + $elseIfCount + $forCount + $foreachCount + 
                                      $whileCount + $doWhileCount + $switchCount + $caseCount + 
                                      $catchCount + $conditionalOpCount
                                      
                    if ($fileMethodCount -gt 0) {
                        $fileComplexity = [math]::Round($fileBranchCount / $fileMethodCount, 1)
                    } 
                    else {
                        $fileComplexity = 0
                    }
                    
                    $totalComplexity += $fileBranchCount
                    $methodCount += $fileMethodCount
                    
                    $complexityByFile += [PSCustomObject]@{
                        File = $file.Name
                        Methods = $fileMethodCount
                        Branches = $fileBranchCount
                        Complexity = $fileComplexity
                    }
                }
            }
            catch {
                Write-Host "Error calculating complexity for $($file.FullName): $_"
            }
        }
        
        # Show details for the top 10 most complex files
        Write-Host "`nTop 10 files by complexity:"
        $complexityByFile | Sort-Object -Property Complexity -Descending | Select-Object -First 10 | 
            Format-Table -Property File, Methods, Branches, Complexity
        
        if ($methodCount -gt 0) {
            $complexity = [math]::Round($totalComplexity / $methodCount, 1)
        }
        else {
            $complexity = 0
            Write-Host "WARNING: No methods found for complexity analysis"
        }
        
        # Calculate maintainability index
        $totalLinesOfCode = 0
        $totalCommentLines = 0
        $linesByFile = @()
        
        foreach ($file in $csFiles) {
            try {
                $content = Get-Content -Path $file.FullName -ErrorAction Continue
                if ($content) {
                    $fileLines = $content.Count
                    $commentLines = @($content | Where-Object { $_ -match "^\s*(//|/\*|\*)" }).Count
                    
                    $totalLinesOfCode += $fileLines
                    $totalCommentLines += $commentLines
                    
                    $linesByFile += [PSCustomObject]@{
                        File = $file.Name
                        Lines = $fileLines
                        CommentLines = $commentLines
                        CommentPercentage = if ($fileLines -gt 0) { [math]::Round(($commentLines / $fileLines) * 100, 1) } else { 0 }
                    }
                }
            }
            catch {
                Write-Host "Error counting lines in $($file.FullName): $_"
            }
        }
        
        # Show details for the top 10 largest files
        Write-Host "`nTop 10 largest files by line count:"
        $linesByFile | Sort-Object -Property Lines -Descending | Select-Object -First 10 | 
            Format-Table -Property File, Lines, CommentLines, CommentPercentage
        
        if ($totalLinesOfCode -gt 0) {
            $commentPercentage = [math]::Round(($totalCommentLines / $totalLinesOfCode) * 100, 1)
            
            # Improved maintainability formula based on industry standards
            # (Microsoft's formula is 171 - 5.2 * ln(avgLoc) - 0.23 * avgCyclomatic - 16.2 * ln(avgHalstead))
            # Using a simplified version since we can't calculate Halstead Volume easily
            
            $linesPerMethod = if ($methodCount -gt 0) { $totalLinesOfCode / $methodCount } else { 50 }
            $commentRatio = ($commentPercentage / 100) # as a decimal
            
            # Basic formula: Higher is better (0-100 scale)
            $rawMaintainability = 171 - 5.2 * [math]::Log($linesPerMethod) - 0.23 * $complexity + 40 * $commentRatio
            $maintainability = [math]::Max(0, [math]::Min(100, [math]::Round($rawMaintainability, 1)))
        }
        else {
            $maintainability = 0
            $commentPercentage = 0
            Write-Host "WARNING: No lines of code found for maintainability analysis"
        }
        
        # Get coverage values from previous steps or use default values
        $lineCoverage = "${{ steps.coverage.outputs.line_coverage || '0.0' }}"
        $branchCoverage = "${{ steps.coverage.outputs.branch_coverage || '0.0' }}"
        
        # If the values are empty strings, set them to 0
        if ([string]::IsNullOrEmpty($lineCoverage) -or $lineCoverage -eq "null") { $lineCoverage = "0.0" }
        if ([string]::IsNullOrEmpty($branchCoverage) -or $branchCoverage -eq "null") { $branchCoverage = "0.0" }
        
        # Convert to double for calculations
        $lineCoverageDouble = [double]$lineCoverage
        $branchCoverageDouble = [double]$branchCoverage
        
        # Test coverage message
        $coverageMessage = if ($lineCoverageDouble -gt 0) { "(Test coverage collected)" } else { "(Test coverage not collected)" }
        
        # Summary statistics
        Write-Host "`nSummary Statistics:"
        Write-Host "Total C# Files: $codeFiles"
        Write-Host "Total Methods: $methodCount"
        Write-Host "Total Public Members: $totalPublicMembers"
        Write-Host "Documented Members: $documentedMembers"
        Write-Host "Documentation Coverage: $docCoverage%"
        Write-Host "Average Cyclomatic Complexity: $complexity"
        Write-Host "Total Lines of Code: $totalLinesOfCode"
        Write-Host "Comment Lines: $totalCommentLines"
        Write-Host "Comment Percentage: $commentPercentage%"
        Write-Host "Maintainability Index: $maintainability"
        Write-Host "Line Coverage: $lineCoverage% $coverageMessage"
        Write-Host "Branch Coverage: $branchCoverage% $coverageMessage"
        
        # Create metrics report content
        $summaryContent = "# Environment Manager Code Quality Metrics`n`n"
        
        $summaryContent += "| Metric | Value | Target |`n"
        $summaryContent += "|--------|-------|--------|`n"
        $summaryContent += "| Cyclomatic Complexity (Avg) | $complexity | <15 |`n"
        $summaryContent += "| Maintainability Index | $maintainability | >80 |`n"
        $summaryContent += "| Documentation Coverage | $docCoverage% | >90% |`n"
        $summaryContent += "| Line Coverage | $lineCoverage% | >80% |`n"
        $summaryContent += "| Branch Coverage | $branchCoverage% | >70% |`n"
        
        $summaryContent += "`n## Code Statistics`n"
        $summaryContent += "- Files: $codeFiles`n"
        $summaryContent += "- Methods: $methodCount`n"
        $summaryContent += "- Public Members: $totalPublicMembers`n"
        $summaryContent += "- Documented Members: $documentedMembers`n"
        $summaryContent += "- Total Lines of Code: $totalLinesOfCode`n"
        $summaryContent += "- Comment Lines: $totalCommentLines ($commentPercentage%)`n"
        
        # Create documentation coverage report
        $docReportContent = "# Documentation Coverage Report`n`n"
        $docReportContent += "| File | Public Members | Documented | Coverage |`n"
        $docReportContent += "|------|---------------|------------|---------|`n"
        
        $fileDetails | Sort-Object -Property DocPercentage | ForEach-Object {
            $docReportContent += "| $($_.File) | $($_.PublicMembers) | $($_.DocumentedMembers) | $($_.DocPercentage)% |`n"
        }
        
        # Create complexity report
        $complexityReportContent = "# Code Complexity Report`n`n"
        $complexityReportContent += "| File | Methods | Branches | Complexity |`n"
        $complexityReportContent += "|------|---------|----------|------------|`n"
        
        $complexityByFile | Sort-Object -Property Complexity -Descending | ForEach-Object {
            $complexityReportContent += "| $($_.File) | $($_.Methods) | $($_.Branches) | $($_.Complexity) |`n"
        }
        
        # Save reports to files
        Set-Content -Path "metrics/reports/metrics_summary.md" -Value $summaryContent
        Set-Content -Path "metrics/reports/documentation_report.md" -Value $docReportContent
        Set-Content -Path "metrics/reports/complexity_report.md" -Value $complexityReportContent
        
        # Display the summary report in the logs
        Get-Content "metrics/reports/metrics_summary.md"

    - name: List Generated Reports
      run: |
        echo "Generated reports:"
        ls -la metrics/reports/

    - name: Upload metrics reports as artifacts
      uses: actions/upload-artifact@v4
      with:
        name: code-metrics-reports
        path: metrics/reports/
        
    # Only upload coverage report if it was generated
    - name: Upload coverage report as artifact
      if: steps.coverage_step.outputs.coverage_generated == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: metrics/reports/coverage/
        
    - name: Create summary
      run: |
        echo "## Code Quality Metrics" >> $GITHUB_STEP_SUMMARY
        cat metrics/reports/metrics_summary.md >> $GITHUB_STEP_SUMMARY
        echo "See detailed reports in the workflow artifacts." >> $GITHUB_STEP_SUMMARY 